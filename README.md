# DevTUI
<!-- START_SECTION:BADGES_SECTION -->
<a href="docs/img/badges.svg"><img src="docs/img/badges.svg" alt="Project Badges" title="Generated by badges.sh from github.com/cdvelop/devscripts"></a>
<!-- END_SECTION:BADGES_SECTION -->

Interactive Terminal User Interface library for Go applications development (principal tui in [**GoDEV** App](https://github.com/cdvelop/godev))

![devtui](tui.jpg)

## Quick Start

DevTUI uses a handler-based architecture where fields implement the `FieldHandler` interface for automatic async operations and message tracking.

```go
package main

import (
    "fmt"
    "strings"
    "sync"
    "time"
    "github.com/cdvelop/devtui"
)

// Handler implementing both interfaces
type HostHandler struct {
    currentHost string
    lastOpID    string
}

// WritingHandler methods
func (h *HostHandler) Name() string { return "HostHandler" }
func (h *HostHandler) SetLastOperationID(id string) { h.lastOpID = id }
func (h *HostHandler) GetLastOperationID() string { return h.lastOpID }

// FieldHandler methods  
func (h *HostHandler) Label() string { return "Host" }
func (h *HostHandler) Value() string { return h.currentHost }
func (h *HostHandler) Editable() bool { return true }
func (h *HostHandler) Timeout() time.Duration { return 5 * time.Second }
func (h *HostHandler) Change(newValue any, progress ...func(string)) (string, error) {
    host := strings.TrimSpace(newValue.(string))
    if host == "" {
        return "", fmt.Errorf("host cannot be empty")
    }
    
    // Use progress callback for real-time updates
    if len(progress) > 0 {
        progressCallback := progress[0]
        progressCallback("Validating host configuration...")
        time.Sleep(500 * time.Millisecond)
        progressCallback("Checking network connectivity...")
        time.Sleep(500 * time.Millisecond)
        progressCallback("Host validation complete")
    } else {
        time.Sleep(1 * time.Second) // Fallback for sync execution
    }
    
    h.currentHost = host
    return fmt.Sprintf("Host configured: %s", host), nil
}

func main() {
    tui := devtui.NewTUI(&devtui.TuiConfig{
        AppName: "MyApp",
        ExitChan: make(chan bool),
    })
    
    tui.NewTabSection("Server", "Configuration").
        NewField(&HostHandler{currentHost: "localhost"})

    var wg sync.WaitGroup
    wg.Add(1)
    go tui.Start(&wg)
    wg.Wait()
}
```

## Interfaces

```go
type FieldHandler interface {
    WritingHandler                                      // Embedded for message tracking
    Label() string                                      // Field display name
    Value() string                                      // Current field value
    Editable() bool                                     // true=input, false=action
    Change(newValue any, progress ...func(string)) (string, error) // Handle changes with progress
    Timeout() time.Duration                             // Operation timeout
}

type WritingHandler interface {
    Name() string                          // Handler identifier (must be unique)
    SetLastOperationID(id string)         // Set operation ID for message updates
    GetLastOperationID() string           // Get operation ID for message reuse
}
```

## Features

- **Dynamic Progress Messages**: Real-time progress updates with custom messages
- **Message Update In-Place**: Operations update existing messages instead of creating new ones
- **Handler-based Architecture**: Clean separation of concerns with interface-based design
- **Automatic Async Operations**: Operations run asynchronously with progress feedback
- **Operation ID Tracking**: Messages are tracked and updated using operation IDs
- **Configurable Timeouts**: Each handler can specify its own timeout duration
- **Multiple Handler Instances**: Same handler type can have multiple instances with unique names

## Progress Callback Usage

The `Change` method receives an optional progress callback that can be used to provide real-time feedback:

```go
func (h *BuildHandler) Change(newValue any, progress ...func(string)) (string, error) {
    if len(progress) > 0 {
        progressCallback := progress[0]
        
        // Simple message updates
        progressCallback("Initiating build process...")
        time.Sleep(500 * time.Millisecond)
        
        progressCallback("Compiling source code...")
        time.Sleep(1 * time.Second)
        
        progressCallback("Build complete")
    }
    
    return "Build completed successfully", nil
}
```

Each progress call updates the same message line in the TUI, providing smooth real-time feedback without cluttering the interface.

## Important Notes

### Handler Name Uniqueness
When using multiple instances of the same handler type, ensure each has a unique name:

```go
type BuildHandler struct {
    buildType string
    lastOpID  string
}

func (h *BuildHandler) Name() string { 
    return fmt.Sprintf("Build_%s", h.buildType) // Unique per instance
}

// Usage
prodBuild := &BuildHandler{buildType: "Production"}
devBuild := &BuildHandler{buildType: "Development"}
```

This ensures each handler maintains its own message history and updates correctly.

## Navigation
- **Tab/Shift+Tab**: Switch between tabs
- **Left/Right**: Navigate fields within tab  
- **Enter**: Edit/Execute
- **Esc**: Cancel edit
- **Ctrl+C**: Exit

## Documentation
- [Advanced Examples](docs/EXAMPLES.md) - Multiple handlers and complex scenarios
- [Migration Guide](docs/MIGRATION_GUIDE.md) - Update existing handlers
